<script src="d3.v3.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<style>
.network {
  border: 1px solid #DEDEDE;
  display:block;
  margin:auto;
}

svg {
  margin: auto;
  display:block;
}

rect {
  fill: none;
  pointer-events: all;
}

circle {
	display:block;
}

line {
	display:block;
}

circle[cx=NaN] {
	display:none !important;
}

circle[cy=NaN] {
	display:none !important;
}

line[x1=NaN] {
	display:none !important;
}

line[y1=NaN] {
	display:none !important;
}

line[x2=NaN] {
	display:none !important;
}

line[y2=NaN] {
	display:none !important;
}


.node {
  fill: #000;
}

.link {
  stroke: #999;
}
</style>
<table>
<tr>
<td>
</td>
<td>
<div class="network">
</div>
</td>
<td>
<b>new blocks</b>
<div id="newblocklog" style="height: 500px; overflow: hidden">
</div>
</td>
<td bgcolor="gray">&nbsp;&nbsp;</td>
<td>
<div id="revenue" style="height: 500px; overflow: hidden">
</div>
</td>
</tr>
</table>
<br />
<span id='timenow'>0 seconds elapsed</span>
<br />
<a href="#" id="faster">faster</a> | <a href="#" id="slower">slower</a> | <a href="#" id="default">default</a> | <a href="#" id="stop">stop</a> | <a href="#" id="addnode">add node</a> | <a href="#" id="attack">node 0 selfish mine</a> | <a href="#" id="sybil">node 0 maxpeers 100</a>
<script>

function revchart(r, h) {
	var res = "<table><tr><td>node</td><td>revenue</td></tr>";
	// sort r
	var n = [];
	for (var id in r) {
		n.push({id:id,rev:r[id]})
	}
	n.sort(function(a,b) {
		if (a.rev == b.rev) return 0;

		return a.rev > b.rev ? -1 : 1;
	})
	for (var i=0;i<n.length;i++) {
		res += "<tr><td>" + n[i].id + "</td><td>" + n[i].rev + " (" + ((n[i].rev/h)*100).toFixed(2) + "%)<br /></td></tr>";
	}
	return res + "</table>";
}

// init with .network for network class div
function Visualizer(div) {
	this.divname = div;
}

Visualizer.prototype = {
	width: 1000,
	height: 500,
	linkDistance: 30,
	charge: -100,
	gravity: .5,
	nindex: 0, // the cursor of the nodes array

	svg: null,
	force: null,
	nodes: null,
	links: null,
	slink: null,
	snode: null,
	edges: {},
	inodes: [],
	updated:false,

	colormap:{},
	colormap_u:false,

	init: function() {
		// init the network layout/svg
		$(this.divname).css('width', this.width);
		$(this.divname).css('height', this.height);

		this.force = d3.layout.force()
			.size([this.width,this.height])
			.nodes([]) // no nodes
			.linkDistance(this.linkDistance)
			.charge(this.charge)
			.gravity(this.gravity);

		this.svg = d3.select(this.divname).append("svg")
	    	.attr("width", this.width)
	    	.attr("height", this.height);

	   	this.svg.append("rect")
		    .attr("width", this.width)
		    .attr("height", this.height);

		this.nodes = this.force.nodes();
		this.links = this.force.links();
		this.slink = this.svg.selectAll(".link");
		this.snode = this.svg.selectAll(".node");

		this.force = this.force.on("tick", this.tick());

		this.updated = true;
		this.rehash();
	},

	setColor: function(p, color) {
		this.colormap_u = true;
		this.colormap[p] = color;
	},

	getRandomLink: function() {
		var result;
		var count=1;
		for (var prop in this.edges) {
			if (Math.random() < 1/++count)
				result = prop;
		}
		if (!result)
			return -1;
		var e = result.split("-");
		return [parseInt(e[0]), parseInt(e[1])];
	},

	getRandomNode: function() {
		return this.inodes[Math.floor(Math.random()*this.inodes.length)];
	},

	getKeyForID: function(id) {
		return this.inodes.indexOf(id);
	},

	incCharge: function(amt) {
		this.force.charge(this.force.charge() - amt);
		this.updated = true;
		///////////this.rehash();
	},

	addNode: function() {
		// add a node, return the index
		this.nodes.push({id:"n"+this.nindex});
		this.inodes.push(this.nindex);
		this.updated = true;
		/////////////this.rehash();

		this.nindex++;
		return this.nindex-1;
	},

	connect: function(a, b) {
		if (this.edges.hasOwnProperty(a + '-' + b) || this.edges.hasOwnProperty(b + '-' + a))
			return false; // we're already connected

		if (a==b)
			return false; // can't connect to ourself silly!

		//console.log('CONNECTING EDGES ' + a + ' AND ' + b);
		this.edges[a + '-' + b] = {source:this.nodes[this.getKeyForID(a)],target:this.nodes[this.getKeyForID(b)]};
		this.links.push(this.edges[a + '-' + b]);

		this.updated = true;
		//////this.rehash();
	},

	disconnect: function(a, b) {
		if (!this.edges.hasOwnProperty(a + '-' + b) && !this.edges.hasOwnProperty(b + '-' + a))
			return false; // we're already disconnected

		var i = this.links.indexOf(this.edges[a + '-' + b]);
		if (i<0)
			i = this.links.indexOf(this.edges[b + '-' + a]);

		delete this.edges[a + '-' + b];
		delete this.edges[b + '-' + a];

		this.links.splice(i, 1); // remove the link

		this.updated = true;
		//////this.rehash();
	},

	removeNode: function(index) {
		// remove a node at index
		var i = this.getKeyForID(index);
		if (i < 0)
			return false; // this one has already been removed

		this.nodes.splice(i, 1);
		this.inodes.splice(i, 1);
		this.updated = true;
		///////////////////this.rehash();
	},

	tick: function() {
		var svg = this.svg;
		return function() {
			svg.selectAll(".link").attr("x1", function(d) { return d.source.x; })
				.attr("y1", function(d) { return d.source.y; })
				.attr("x2", function(d) { return d.target.x; })
				.attr("y2", function(d) { return d.target.y; });

			svg.selectAll(".node").attr("cx", function(d) { return d.x; })
				.attr("cy", function(d) { return d.y; });
		}
	},

	rehash: function() {
		/***** COLORMAP *****/
		if (this.colormap_u) {
			for (var p in this.colormap) {
				$(".n" + p).css('fill', this.colormap[p]);
			}
			this.colormap_u = false;
		}

		if (!this.updated)
			return;

		this.slink = this.slink.data(this.force.links(), function(d) { return d.source.id + "-" + d.target.id; });
		this.slink.enter().insert("line", ".node")
			.attr("class", "link");
		this.slink.exit().remove();

		this.snode = this.snode.data(this.force.nodes(), function(d) {return d.id;});
		this.snode.enter().append("circle").attr("class", function (d) {return "node " + d.id;})
			.attr("r", 3)
			.call(this.force.drag);
		this.snode.exit().remove();

		this.force.start();

		this.updated = false;
	}
};

// Array Remove - By John Resig (MIT Licensed)
Array.prototype.remove = function(from, to) {
  var rest = this.slice((to || from) + 1 || this.length);
  this.length = from < 0 ? this.length + from : from;
  return this.push.apply(this, rest);
};

function BinaryHeap(scoreFunction){
  this.content = [];
  this.scoreFunction = scoreFunction;
}

BinaryHeap.prototype = {
  push: function(element) {
    // Add the new element to the end of the array.
    this.content.push(element);
    // Allow it to bubble up.
    this.bubbleUp(this.content.length - 1);
  },

  pop: function() {
    // Store the first element so we can return it later.
    var result = this.content[0];
    // Get the element at the end of the array.
    var end = this.content.pop();
    // If there are any elements left, put the end element at the
    // start, and let it sink down.
    if (this.content.length > 0) {
      this.content[0] = end;
      this.sinkDown(0);
    }
    return result;
  },

  remove: function(node) {
    var length = this.content.length;
    // To remove a value, we must search through the array to find
    // it.
    for (var i = 0; i < length; i++) {
      if (this.content[i] != node) continue;
      // When it is found, the process seen in 'pop' is repeated
      // to fill up the hole.
      var end = this.content.pop();
      // If the element we popped was the one we needed to remove,
      // we're done.
      if (i == length - 1) break;
      // Otherwise, we replace the removed element with the popped
      // one, and allow it to float up or sink down as appropriate.
      this.content[i] = end;
      this.bubbleUp(i);
      this.sinkDown(i);
      break;
    }
  },

  size: function() {
    return this.content.length;
  },

  bubbleUp: function(n) {
    // Fetch the element that has to be moved.
    var element = this.content[n], score = this.scoreFunction(element);
    // When at 0, an element can not go up any further.
    while (n > 0) {
      // Compute the parent element's index, and fetch it.
      var parentN = Math.floor((n + 1) / 2) - 1,
      parent = this.content[parentN];
      // If the parent has a lesser score, things are in order and we
      // are done.
      if (score >= this.scoreFunction(parent))
        break;

      // Otherwise, swap the parent with the current element and
      // continue.
      this.content[parentN] = element;
      this.content[n] = parent;
      n = parentN;
    }
  },

  sinkDown: function(n) {
    // Look up the target element and its score.
    var length = this.content.length,
    element = this.content[n],
    elemScore = this.scoreFunction(element);

    while(true) {
      // Compute the indices of the child elements.
      var child2N = (n + 1) * 2, child1N = child2N - 1;
      // This is used to store the new position of the element,
      // if any.
      var swap = null;
      // If the first child exists (is inside the array)...
      if (child1N < length) {
        // Look it up and compute its score.
        var child1 = this.content[child1N],
        child1Score = this.scoreFunction(child1);
        // If the score is less than our element's, we need to swap.
        if (child1Score < elemScore)
          swap = child1N;
      }
      // Do the same checks for the other child.
      if (child2N < length) {
        var child2 = this.content[child2N],
        child2Score = this.scoreFunction(child2);
        if (child2Score < (swap == null ? elemScore : child1Score))
          swap = child2N;
      }

      // No need to swap further, we are done.
      if (swap == null) break;

      // Otherwise, swap and continue.
      this.content[n] = this.content[swap];
      this.content[swap] = element;
      n = swap;
    }
  }
};

// eventchain api, really just a toss up between a linked list
// structure for less common events and a binary heap for frequent
// ones. very accurate and simple (add and next are the only)
// supported operations
function EventChain() {
	this.heap = new BinaryHeap(function(x) {return x.time;})
	this.cache = false;
	this.quickhead = false;

	// add an event to a linked list
	this.quickadd = function(time, event) {
		var cur = this.quickhead;
		var prev = false;

		while(true) {
			if (!cur) {
				var struct = {time:time,event:event,next:false}

				if (prev)
					prev.next = struct;
				else
					this.quickhead = struct;

				break;
			} else if (cur.time > time) {
				var struct = {time:time,event:event,next:cur}

				if (prev)
					prev.next = struct;
				else
					this.quickhead = struct;

				break;
			}

			prev = cur;
			cur = cur.next;
		}
	}

	// used internally
	this.quicktime = function() {
		if (this.quickhead)
			return this.quickhead.time;
		else
			return Number.POSITIVE_INFINITY;
	}

	// used internally
	this.quickpop = function() {
		var ret = {time:this.quickhead.time,event:this.quickhead.event};
		this.quickhead = this.quickhead.next;
		return ret;
	}

	// add event to binary heap
	this.add = function(time, event) {
		if (this.cache && (time < this.cache.time)){
			this.heap.push(this.cache)
			this.cache = false;
		}

		this.heap.push({time:time,event:event})
	}

	// visit the next event unless the event occurs
	// on or after maxtime
	this.next = function(maxtime) {
		var ret;
		if (!this.cache)
			ret = this.heap.pop();
		else
			ret = this.cache;

		if (!ret || (ret.time > this.quicktime())) {
			if (ret) this.cache = ret;

			// quick goes first, if at all
			if (this.quicktime() < maxtime) {
				return this.quickpop();
			}

			return false;
		} else {
			if (ret.time >= maxtime) {
				this.cache = ret;
				return false;
			} else {
				this.cache = false;
				return ret;
			}
		}
	}
}

// the node's local state, or what it will know as "self"
function NodeState(node, network, id) {
	this.node = node;
	this.id = id;
	this.network = network;
	this.visualizerId = -1;
	this.mprob = 0;

	this.mine = function(p) {
		if (p === false) {
			this.mprob = 0;
		} else if (p === true) {
			network.mining.new(this);
		} else {
			this.mprob = p;
			if (network.mining.unreserved < p)
				return false;

			network.mining.unreserved -= p;
			this.startMining(); // start mining
		}

		return true;
	}

	this.onMined = function(self) {
		self.blockchain.mine(self.now());

		self.startMining();
	}

	this.startMining = function() {
		this.stopMining();
		if (this.mprob > 0) {
			this.prob("mining", 100, (this.mprob / this.blockchain.getstate().difficulty), this.onMined);
		}
		this.setColor(this.blockchain.getstate().color);
		this.peers.broadcast("status", this.blockchain.chainstate.get());
	}

	this.stopMining = function() {
		this.deprob("mining")
	}

	this.prob = function(label, delay, p, f) {
		this.network.pregister(label, delay, p, this.id, f)
	}

	this.deprob = function(label) {
		this.network.depregister(label, this.id)
	}

	this.setColor = function(color) {
		this.network.setColor(this.visualizerId, color);
	}

	// send another node in the network a message
	this.send = function(nid, name, obj) {
		// TODO: a cooler latency computation! maybe based on JSON.stringify size of obj too
		var delay = Math.floor(Math.random() * 5000) + 50;

		this.network.exec(new NodeMessageEvent(this.id, delay, nid, name, obj))
	}

	this.handle = function(from, name, obj) {
		if (typeof this.node._handlers[name] != "undefined") {
			this.node._handlers[name](this, from, obj)
		}
	}

	this.now = function() {
		return this.network.now;
	}

	this.peers = new PeerMgr(this);
	this.blockchain = new Blockchain(this);
}

// simple interface for an event that occurs in the simulation
function NodeEvent(delay, nid, f) {
	this.nid = nid;
	this.delay = delay;

	this.run = function(network) {
		f(network.nodes[this.nid]);
	}
}

// like NodeEvent, but used to call handler functions on nodes
function NodeMessageEvent(from, delay, nid, name, obj) {
	this.nid = nid;
	this.delay = delay;

	this.run = function(network) {
		network.nodes[this.nid].handle(from, name, obj) // tell the node to handle the message
	}
}

// like a NodeMessageEvent, except we create a new event after we run
function NodeTickEvent(delay, nid, f) {
	this.nid = nid;
	this.delay = delay;

	this.run = function(network) {
		if (f(network.nodes[this.nid]) !== false)
			network.exec(this) // register ourselves again!
	}
}

// like NodeTickEvent, but probabilistic
function NodeProbabilisticTickEvent(delay) {
	this.delay = delay;
	this.events = {}
	this.pnothing = 1;
	this.ptotal = 0;
	this.numevents = 0;

	this.register = function(p, nid, f) {
		// p is the probability of the event firing at the given moment

		this.events[nid] = {p:p, f:f}; // store the event
		this.pnothing *= 1-p; // the probability of nothing happening decreases
		this.ptotal += p;
		this.numevents++;
	}

	this.deregister = function(nid) {
		if (typeof this.events[nid] != "undefined") {
			this.pnothing /= 1-(this.events[nid].p);
			this.ptotal -= this.events[nid].p;
			delete this.events[nid];
			this.numevents--;
		}
	}

	this.runevent = function(network) {
		var which = Math.random() * this.ptotal;

		var cur = 0;
		for (var nid in this.events) {
			cur += this.events[nid].p;

			if (which <= cur) {
				this.events[nid].f(network.nodes[nid])
				break;
			}
		}
	}

	this.run = function(network) {
		var ecount = 0;

		while (Math.random() > this.pnothing) {
			ecount++;
		}

		while (ecount > 0) {
			// which event should occur?
			this.runevent(network)
			ecount--;
		}

		if (this.numevents) {
			network.quickexec(this); // register ourselves again! we still have events that could occur again
		}
	}
}

function MiningPool() {
	this.unreserved = 1;
	this.unreserved_pool = [];

	this.new = function(node) {
		this.unreserved_pool.push(node);
	}

	this.setup = function() {
		var m;
		var per = this.unreserved / this.unreserved_pool.length;

		for (var i=0;i<this.unreserved_pool.length;i++) {
			m = this.unreserved_pool[i];

			m.mprob = per;
			m.startMining();
		}
	}
}

function Network(visualizerDiv) {
	this.events = new EventChain(); // normal events
	this.mining = new MiningPool();
	this.pevents = {}; // probablistic event references
	this.visualizer = new Visualizer(visualizerDiv);
	if (typeof visualizerDiv != "undefined") {
		$(visualizerDiv).html();
		this.visualizer.init();
	}
	this.now = 0;

	this.nodes = [];
	this.nindex = 0;

	this.vars = {besth:-1,revenue:{},lastblocks:[]};

	// registers a probabilistic event
	this.pregister = function(label, delay, p, nid, cb) {
		//console.log("label: " + label + "; delay: " + delay + "; p: " + p + "; nid: " + nid + ";")
		if (typeof this.pevents[label] == "undefined") {
			this.pevents[label] = new NodeProbabilisticTickEvent(delay)
			this.quickexec(this.pevents[label])
		}
		
		this.pevents[label].register(p, nid, cb)
	}

	// deregisters a probablistic event
	this.depregister = function(label, nid) {
		if (typeof this.pevents[label] != "undefined") {
			this.pevents[label].deregister(nid)
		}
	}

	this.setColor = function(vid, color) {
		if (typeof visualizerDiv != "undefined") {
			this.visualizer.setColor(vid, color);
		}
	}

	// registers an event to occur, only use this for a few rare things
	this.quickexec = function(e) {
		this.events.quickadd(e.delay+this.now, e)
	}

	// registers an event to occur
	this.exec = function(e) {
		this.events.add(e.delay+this.now, e)
	}

	// connects two nodes in the visualizer
	this.connect = function (a, b) {
		if (typeof visualizerDiv != "undefined") {
			this.visualizer.connect(this.nodes[a].visualizerId, this.nodes[b].visualizerId);
		}
	}

	// disconnects two nodes in the visualizer
	this.disconnect = function (a, b) {
		if (typeof visualizerDiv != "undefined") {
			this.visualizer.disconnect(this.nodes[a].visualizerId, this.nodes[b].visualizerId);
		}
	}

	// adds amt node objects to the network simulator
	this.add = function(amt, node) {
		for (;amt>0;amt--) {
			var state = new NodeState(node, this, this.nindex);
			if (typeof visualizerDiv != "undefined")
				state.visualizerId = this.visualizer.addNode();
			node._init(state);
			for (var i=0;i<node._ticks.length;i++) {
				var t = node._ticks[i]
				this.exec(new NodeTickEvent(t.delay, this.nindex, t.f))
			}
			this.nodes[this.nindex] = state; // init and receive a state object back
			this.nindex++;
		}

		this.mining.setup();
	}

	// run buffer time worth of tasks
	this.run = function(buffer) {
		var max = this.now+buffer;
		var e = false;
		while (e = this.events.next(max)) {
			this.now = e.time;
			e.event.run(this)
		}

		this.now += buffer;

		var newblocklog = "";
		for (var i=0;i<this.vars.lastblocks.length;i++) {
			newblocklog = "<span style='color:white; background-color: " + this.vars.lastblocks[i].block.color + "'>node " + this.vars.lastblocks[i].node.id + " mined height " + this.vars.lastblocks[i].block.h + "<br /></span>" + newblocklog;
		}
		$("#newblocklog").html(newblocklog);

		$("#revenue").html(revchart(this.vars.revenue, this.vars.besth))

		if (typeof visualizerDiv != "undefined") {
			this.visualizer.rehash();
		}
	}
}

// the base node object just has a bunch of built in handlers
// with peermgr, and probably will have more built in things later
function Node() {
	this._init = function(self) {};
	this._handlers = {
		"connect":function(state, from, obj) {state.peers.event("connect", state, from, obj)},
		"accept":function(state, from, obj) {state.peers.event("accept", state, from, obj)},
		"reject":function(state, from, obj) {state.peers.event("reject", state, from, obj)},
		"disconnect":function(state, from, obj) {state.peers.event("disconnect", state, from, obj)},
		"getpeers":function(state, from, obj) {state.peers.event("getpeers", state, from, obj)},
		"peerlist":function(state, from, obj) {state.peers.event("peerlist", state, from, obj)},
		"status":function(state, from, obj) {
			if (state.peers.isConnected(from)) {
				if (state.blockchain.newstate(obj)) {
					state.startMining();
				}
			}
		}
	};
	this._ticks = [{delay: 1000, f: function(self) {
		return self.peers.tick();
	}}];

	this.init = function(callback) {
		this._init = callback;
	}

	// network events
	this.on = function(event, callback) {
		this._handlers[event] = callback;
	}

	this.tick = function(delay, callback) {
		this._ticks.push({delay: delay, f: callback})
	}
}

// will need to update this to interact with the messageevents somehow?
function PeerState(id, lastmessage) {
	this.id = id;
	this.lastmessage = lastmessage;
	this.active = false;
}

// PeerMgr for handling connections to other nodes.
function PeerMgr(node) {
	this.curpeers = 0;
	this.maxpeers = 8; // max number of peers we want
	this.peers = {}; // peer index
	this.nodearchive = [new PeerState(0, node.now())]; // seed with bootstrap node, archive of remote peers

	this.event = function(name, node, from, obj) {
		switch (name) {
			case "accept":
				if (typeof this.peers[from] != "undefined") {
					// remote node has accepted our connection request
					// remove them from our nodearchive
					for (var i=0;i<this.nodearchive.length;i++) {
						if (this.nodearchive[i].id == from) {
							this.nodearchive.remove(i);
						}
					}

					// set the connection as active
					this.peers[from].lastmessage = node.now();
					this.peers[from].active = true;

					// notify network of connection
					node.network.connect(node.id, from)
				}
			break;
			case "reject":
				// remote peer rejected our connect request
				if (typeof this.peers[from] != "undefined") {
					this.event("peerlist", node, from, obj) // get peerlist
					delete this.peers[from];
					this.curpeers -= 1;
				}
			break;
			case "connect":
				// remote node trying to connect to us
				// do we have enough peers already?
				if (Object.keys(this.peers).length < this.maxpeers) {
					// you can connect
					this.peers[from] = new PeerState(from, node.now());
					this.curpeers += 1;
					this.event("accept", node, from, obj);
					this.accept(from)
				} else {
					for (var k=0;k<this.nodearchive.length;k++) {
						if (this.nodearchive[k].id == from) {
							this.nodearchive.remove(k);
						}
					}

					this.nodearchive.unshift(new PeerState(from, node.now()))

					this.reject(from)
				}
			break;
			case "disconnect":
				// remote node disconnected
				if (typeof this.peers[from] != "undefined") {
					delete this.peers[from];
					this.curpeers -= 1;
					this.nodearchive.push(new PeerState(from, node.now()));

					// notify network of disconnection
					node.network.disconnect(node.id, from)
				}
			break;
			case "getpeers":
				// remote node wants peer list from us
				if (typeof this.peers[from] != "undefined") {
					this.sendpeers(from);
				}
			break;
			case "peerlist":
				if (typeof this.peers[from] != "undefined") {
					// add these peers to our nodearchive
					// if we don't have them already

					for (var i=0;i<obj.length;i++) {
						var candidate = obj[i];

						for (var k=0;k<this.nodearchive.length;k++) {
							if (this.nodearchive[k].id == candidate.id) {
								this.nodearchive.remove(k);
							}
						}

						this.nodearchive.unshift(new PeerState(candidate.id, node.now()))
					}
				}
			break;
		}
	}

	// find other peers
	this.tick = function() {
		if (node.now() > 500000)
			return false;

		//console.log(node.id + ": I have " + Object.keys(this.peers).length + " peers")
		if (this.curpeers < this.maxpeers) {
			// we need new peers
			// 1: getpeers to other peers
			// 2: connect to new peers in our nodearchive if there are any

			if (this.nodearchive.length) {
				var p = this.nodearchive.shift();
				this.nodearchive.push(p);

				if (typeof this.peers[p.id] == "undefined")
					this.connect(p)
			}

			if (Object.keys(this.peers).length) {
				var randomPeer = this.peers[Object.keys(this.peers)[Math.floor(Math.random() * Object.keys(this.peers).length)]]

				if (randomPeer.active) {
					this.getpeers(randomPeer.id)
				}
			}
		}
	}

	this.isConnected = function(p) {
		return (typeof this.peers[p] != "undefined") && this.peers[p].active
	}

	this.broadcast = function(name, obj) {
		// send the same message to all of our (active) peers
		for (var p in this.peers) {
			if (this.peers[p].active) {
				this.send(p, name, obj);
			}
		}
	}

	// why abstract this? i don't know yet.
	this.send = function(p, name, obj) {
		node.send(p, name, obj);
	}

	this.getpeers = function(p) {
		node.send(p, 'getpeers', {});
	}

	this.sendpeers = function(p, peers) {
		node.send(p, 'peerlist', this.nodearchive.slice(0, 15));
	}

	this.accept = function(p) {
		node.send(p, 'accept', {})
	}

	this.reject = function(p) {
		node.send(p, 'reject', this.nodearchive.slice(0, 15))
	}

	// send a connect message to a peer
	this.connect = function(p) {
		this.peers[p.id] = p;
		this.curpeers += 1;
		node.send(p.id, 'connect', {})
	}

	// send a disconnect message to a peer
	this.disconnect = function(id) {
		delete this.peers[p.id];
		this.curpeers -= 1;
		node.send(id, 'disconnect', {})
	}
}

// todo remove this crap
var cindex = 0;
var colors = ["red","green","blue","purple","orange","chartreuse","darkred","dodgerblue"]

function randomColor() {
	cindex++;

	return colors[cindex % colors.length]
}

function Block(h, prev, time, credit) {
	if (h == 0) {
		this.id = "genesis";
		prev = false;
	} else {
		this.id = (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)) + (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)) + (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)); // just random data lol
	}

	this.h = h;
	this.prev = prev;
	this.color = randomColor();
	this.time = time;
	this.revenue = {};
	this.transactions = [];
	if (prev) {
		this.difficulty = prev.difficulty;
		this.signature = credit.id;
	}
	else {
		this.difficulty = 1000;
		this.signature = false;
	}

	if (this.h != 0) {
		credit.network.vars.lastblocks.push({node:credit,block:this})

		if (this.h > 50) {
			credit.network.vars.lastblocks.shift()
		}
	}

	this.report = function() {
		credit.network.vars.besth = this.h;
		credit.network.vars.revenue = this.revenue;
	}
}

// keep it simple at first
function Transaction(input) {
	this.id = (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)) + (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)) + (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)); // just random data lol
    this.outputs = [];

    var no = Math.floor(Math.random() * 2) + 1;

    for (var i=no;i>0;i--) {
    	this.outputs.push((Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)) + (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)) + (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)));
    }

    this.inputs = [input];
    this.coinbase = false;

    // returns a string representation of inputs lol in an array
    this.getInputs = function() {
    	return this.inputs;
    }

    // returns a string representation of outputs lol in an array
    this.getOutputs = function() {
    	return this.outputs;
    }
}

function Mempool() {
	this.transactions = {};
	this.depends = {}; // lol

	// removes a transaction from the mempool
	// will also remove any transactions which depend on its inputs
	this.remove = function(tx) {
		var inputs = tx.getInputs();
		var outputs = tx.getOutputs();

		for (var i=0;i<outputs.length;i++) {
			if (typeof this.depends[outputs[i]] != "undefined") {
				this.remove(this.depends[outputs[i]]); // remove this one too
			}
		}

		// we don't depend on any inputs anymore
		for (var i=0;i<inputs.length;i++) {
			delete this.depends[inputs[i]]
		}

		delete this.transactions[tx.id]
	}

	// a reorg has re-introduced a transaction into the mempool
	this.unconfirm = function(tx) {
		// all of this transaction's inputs

		if (typeof(this.transactions[tx.id]) != "undefined") {
			return true; // we already have the transaction in the mempool for some reason. this shouldn't happen tbh
		}

		var inputs = tx.getInputs();
		var outputs = tx.getOutputs();

		// check for conflicting transactions we must remove
		for (var i=0;i<inputs.length;i++) {
			if (typeof this.depends[inputs[i]] != "undefined") {
				this.remove(this.depends[inputs[i]])
			}

			// WE depend on this input now
			this.depends[inputs[i]] = tx;
		}

		// does anyone depend on our input? if so, we need to remove them from the mempool
		// because we're not confirmed yet!

		// they'll still be in the depends map, until all of their inputs are confirmed

		for (var i=0;i<outputs.length;i++) {
			// do any transactions in the mempool depend on our outputs?
			if (typeof this.depends[outputs[i]] != "undefined") {
				delete this.transactions[this.depends[outputs[i]].id]
			}
		}

		this.transactions[tx.id] = tx; // add the transaction to the mempool
	}

	// a transaction has entered the chainstate, and should no longer be in the mempool
	this.confirm = function(tx) {
		var inputs = tx.getInputs();
		var outputs = tx.getOutputs();

		for (var i=0;i<inputs.length;i++) {
			// apparently we don't depend on these inputs anymore!
			if (typeof this.depends[inputs[i]] != "undefined") {
				// IS THIS TRANSACTION US
				if (this.depends[inputs[i]].id == tx.id) {
					// YEP!
					delete this.depends[inputs[i]]
				} else {
					// DELETE IT!
					this.remove(this.depends[inputs[i]])
				}
			}
		}

		delete this.transactions[tx.id]; // delete the transaction from the mempool

		for (var i=0;i<outputs.length;i++) {
			if (typeof this.depends[outputs[i]] != "undefined") {
				var dtx = this.depends[outputs[i]];
				var still = false;

				var dtxi = dtx.getInputs();

				// does this dependant tx still depend on any transactions in the mempool?

				for (var ii=0;ii<dtxi.length;ii++) {
					if (typeof this.transactions[dtxi[ii]] != "undefined") {
						still = true;
					}
				}

				if (!still) {
					this.transactions[dtx.id] = dtx; // add this transaction back to the mempool
				}
			}
		}
	}

	// gets a list of all transactions in the mempool
	this.get = function() {
		var l = [];
		for (var id in this.transactions) {
			l.push(this.transactions[id])
		}

		return l;
	}

	// add to the mempool
	// won't ever occur unless the tx uses confirmed UNSPENT inputs

	// returns false if there's a conflict
	this.add = function(tx) {
		// if any of our dependent inputs are already used, return false

		var inputs = tx.getInputs();

		if (typeof this.transactions[tx.id] != "undefined")
			return false; // already in the mempool

		for (var i=0;i<inputs.length;i++) {
			if (typeof this.depends[inputs[i]] != "undefined")
				return false;
		}

		// i guess we can add our tx!

		this.transactions[tx.id] = tx;

		for (var i=0;i<inputs.length;i++) {
			this.depends[inputs[i]] = tx;
		}

		return true;
	}
}

function UTXO() {
	this.utxo = {};

	this.addoutputs = function(tx) {
		var out = tx.getOutputs();

		for (var i=0;i<out.length;i++) {
			this.utxo[out[i]] = true; // someday we'll use a TxOut obj
		}
	}

	this.add = function(tx) {
		if (!this.verifyinputs(tx))
			return false;

		this.spendinputs(tx);
		this.addoutputs(tx);
	}

	this.remove = function(tx) {
		// undo a transaction from the utxo set, like from a reorg

		var txouts = tx.getOutputs();

		for (var i=0;i<txouts.length;i++) {
			delete this.utxo[txouts[i]] // delete this output
		}

		var txins = tx.getInputs();

		for (var i=0;i<txins.length;i++) {
			this.utxo[txins[i]] = true; // someday we'll need to be able to find this TxOut obj
		}
	}

	this.spendinputs = function(tx) {
		var txins = tx.getInputs();

		for (var i=0;i<txins.length;i++) {
			delete this.utxo[txins[i]];
		}
	}

	this.verifyinputs = function(tx) {
		if (tx.coinbase)
			return true; // coinbase transactions don't need valid inputs

		// this transactions' inputs must be in the UTXO set and confirmed

		var txins = tx.getInputs();
		for (var i=0;i<txins.length;i++) {
			if (typeof(this.utxo[txins[i]]) == "undefined")
				return false;
		}

		return true;
	}
}

var GenesisBlock = new Block(0, false, 0);
GenesisBlock.transactions = [new Transaction("_0"), new Transaction("_1"), new Transaction("_2"), new Transaction("_3"), new Transaction("_4")];
GenesisBlock.transactions.map(function(tx) {
	tx.coinbase = true;
	return tx;
})

function Chainstate(starthead) {
	this.head = false;
	this.mempool = new Mempool()
	this.utxo = new UTXO();
	this.rejects = {};

	this.get = function() {
		return this.head;
	}

	this.newtx = function(tx) {
		// we received a new tx over the network or something, should we add to mempool?

		if (typeof this.rejects[tx.id] != "undefined")
			return false; // don't bother

		// 1. all of its inputs must be in the UTXO set
		if (this.utxo.verifyinputs(tx)) {
			// 2. the mempool must be okay with adding it
			if (!this.mempool.add(tx)) {
				this.rejects[tx.id] = true;
				return false;
			} else {
				this.rejects[tx.id] = true;
				return true;
			}
		} else {
			this.rejects[tx.id] = true;
			return false;
		}
	}

	// reverses the head
	//  1. transactions in the block are placed in the mempool
	//  2. transactions' inputs are set to unspent in the transaction pool
	this.reverse = function() {
		// all of the transactions in the current head must now be added to the mempool
		// and removed from UTXO set
		for (var i=0;i<this.head.transactions.length;i++) {
			this.mempool.unconfirm(this.head.transactions[i])
			this.utxo.remove(this.head.transactions[i])
		}

		this.head = this.head.prev;
	}

	// move forward!
	this.forward = function(b) {
		// b is the new head
		// every transaction in b must be removed from the mempool
		// and added to utxo set

		for (var i=0;i<b.transactions.length;i++) {
			this.mempool.confirm(b.transactions[i])
			this.utxo.add(b.transactions[i])
		}

		this.head = b;
	}

	this.set = function(block) {
		var newcur = block.prev;

		var numorphan = 0;
		var forwards = [block];

		while (true) {
			if (this.head == newcur) {
				while(true) {
					// loop through our forward blocks
					if (forwards.length > 0) {
						this.forward(forwards.pop());
					} else {
						break;
					}
				}
				break;
			} else if (this.head.h > newcur.h) {
				this.reverse();
				numorphan++;
			} else if (newcur.h > this.head.h) {
				forwards.push(newcur);
				newcur = newcur.prev;
			} else {
				this.reverse();
				numorphan++;

				forwards.push(newcur);
				newcur = newcur.prev;
			}
		}

		this.rejects = {}; // reset rejects

		return numorphan;
	}

	// unroll our head until we reach the given height
	// used for selfish mining attack
	this.unroll = function(h) {
		var cur = this.head;

		while (cur.h != h) {
			cur = cur.prev;
		}

		return cur;
	}





	this.forward(starthead); // FORWARD!
}

function Blockchain(node) {
	this.chainstate = new Chainstate(GenesisBlock);

	this.attacker_status = false; // selfish mining attack
	this.private_chainstate = new Chainstate(this.chainstate.get());

	this.target_avg_between_blocks = 2.5 * 60 * 1000; // target time between blocks
	this.difficulty_adjustment_period = 2016;

	this.newtx = function(tx) {
		if (this.attacker_status)
			this.private_chainstate.newtx(tx); // add to private chainstate if possible

		return this.chainstate.newtx(tx);
	}

	this.newstate = function(b) {
		if (!this.attacker_status)
			return this._newstate(b);

		var r;
		if (r = this._newstate(b)) {
			// is the new block larger than our private chain?
			if (b.h > this.private_chainstate.get().h) {
				// give up. adopt the new (public) chainstate
				this.private_chainstate.set(this.chainstate.get());
			} else {
				if (b.h == this.private_chainstate.get().h) {
					this.chainstate.set(this.private_chainstate.get()); // publish private chainstate
				} else {
					this.chainstate.set(this.private_chainstate.unroll(b.h+1))
				}
			}
		}

		return r;
	}

	this._newstate = function(b) {
		// is this new block larger than ours?
		if (b.h > this.chainstate.get().h) {
			this.chainstate.set(b);

			if (!this.attacker_status)
				this.private_chainstate.set(b);

			return true;
		}

		return false;
	}

	this.mine = function(now) {
		if (this.attacker_status) {
			// always mine on the private chain

			var newb = new Block(this.private_chainstate.get().h+1, this.private_chainstate.get(), now, node);
			this.diff_adjust(newb);
			newb.transactions = this.private_chainstate.mempool.get();

			this.private_chainstate.set(newb);
		} else {
			// always mine on the public chain

			var newb = new Block(this.chainstate.get().h+1, this.chainstate.get(), now, node);
			this.diff_adjust(newb);
			newb.transactions = this.chainstate.mempool.get();

			this.chainstate.set(newb);
		}
	}

	this.diff_adjust = function(b) {
		if (!(b.h % this.difficulty_adjustment_period)) {
			// this is a difficulty adjustment block

			var total = 0;
			var last = b.time;
			var cur = b.prev;
			for (var i=0;i<this.difficulty_adjustment_period;i++) {
				total += last - cur.time;
				last = cur.time;
				cur = cur.prev;
			}
			var avg = total / this.difficulty_adjustment_period;

			// how much should we change the difficulty by?
			var old = b.difficulty;
			b.difficulty *= this.target_avg_between_blocks / avg; // 10 minutes?

			console.log("(height = " + b.h + ") Difficulty adjustment: from " + old + " to " + b.difficulty + " (" + (this.target_avg_between_blocks / avg) + "x)")

			// awesome, now since we're an adjustment block we can go fetch the revenue from the last diff block and perform a merge
			var newrev = {};

			cur = b;

			while( (cur.h == b.h) || cur.h % this.difficulty_adjustment_period) {
				if (cur.signature !== false) {
					if (typeof newrev[cur.signature] == 'undefined') {
						newrev[cur.signature] = 0;
					}
					newrev[cur.signature] += 1;
				}

				cur = cur.prev;
			}

			// cur should now be a diff adjustment block
			for (var s in cur.revenue) {
				if (typeof newrev[s] == 'undefined') {
					newrev[s] = 0;
				}
				newrev[s] += cur.revenue[s];
			}

			b.revenue = newrev;

			b.report();
		}
	}

	this.getstate = function() {
		if (this.attacker_status)
			return this.private_chainstate.get();

		return this.chainstate.get();
	}
}

var nodes = 200;

var btc = new Node();

// btc.init() - an initialization function (post peermgr)
// btc.tick() - a tick which occurs routinely
// btc.on() - attaching new events

function s4() {
  return Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1);
};

function guid() {
  return s4() + s4() + s4();
}


btc.init(function(self) {
	switch(self.id) {
		case 0:
			self.mine(0.31)
		break;
		case 1:
			self.mine(0.22)
		break;
		case 2:
			self.mine(0.13)
		break;
		case 3:
			self.mine(0.06)
		break;
		case 4:
			self.mine(0.05)
		break;
		case 5:
			self.mine(0.03)
		break;
		case 6:
			self.mine(0.02)
		break;
		case 7:
			self.mine(0.02)
		break;
		default:
			if (self.id < 100)
				self.mine(true);
			else
				self.mine(false);
		break;
	}

	// node will randomly generate a new transaction
	self.prob("newtx", 1000, 0.01, function() {
		// get a random unspent output and just create a transaction with it

		var r = Object.keys(self.blockchain.chainstate.utxo.utxo)[Math.floor(Math.random() * Object.keys(self.blockchain.chainstate.utxo.utxo).length)];

		var newtx = new Transaction(r);

		self.handle(-1, "newtx", newtx);
	})
})

btc.on("newtx", function(self, from, obj) {
	if (self.blockchain.newtx(obj)) {
		//console.log("BROADCASTING TX " + JSON.stringify(obj))
		self.peers.broadcast("newtx", obj)
	}
})

var net = new Network(".network");

net.add(nodes, btc);

var interval = 10;

setInterval(function() {
	net.run(interval);
	$("#timenow").html((net.now/1000) + " seconds elapsed");
}, 10)

$('#faster').click(function() {
	interval *= 2;
})

$('#slower').click(function() {
	interval /= 2;
})

$('#default').click(function() {
	interval = 10;
})

$("#stop").click(function() {
	interval = 0;
})

$("#addnode").click(function() {
	net.add(1, btc);
})

$("#attack").click(function() {
	net.nodes[0].blockchain.attacker_status = true;
})

$("#sybil").click(function() {
	net.nodes[0].peers.maxpeers = 100;
})

</script>